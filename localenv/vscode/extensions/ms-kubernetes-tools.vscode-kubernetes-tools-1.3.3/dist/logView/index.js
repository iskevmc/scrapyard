!function(n){var g={};function t(I){if(g[I])return g[I].exports;var e=g[I]={i:I,l:!1,exports:{}};return n[I].call(e.exports,e,e.exports,t),e.l=!0,e.exports}t.m=n,t.c=g,t.d=function(n,g,I){t.o(n,g)||Object.defineProperty(n,g,{enumerable:!0,get:I})},t.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,g){if(1&g&&(n=t(n)),8&g)return n;if(4&g&&"object"==typeof n&&n&&n.__esModule)return n;var I=Object.create(null);if(t.r(I),Object.defineProperty(I,"default",{enumerable:!0,value:n}),2&g&&"string"!=typeof n)for(var e in n)t.d(I,e,function(g){return n[g]}.bind(null,e));return I},t.n=function(n){var g=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(g,"a",g),g},t.o=function(n,g){return Object.prototype.hasOwnProperty.call(n,g)},t.p="",t(t.s=0)}([function(module,exports){eval("const vscode = acquireVsCodeApi();\nconst fullPageContent = [];\nlet schemaColors;\nlet defaultContainer;\nlet renderNonce = 0;\nlet isToBottom = true;\nlet lastScrollTop = 0;\n\nwindow.addEventListener('message', (event) => {\n    const message = event.data;\n    switch (message.command) {\n        case 'init': {\n            const containers = message.containers;\n            schemaColors = JSON.parse(message.colors);\n            if (containers.length === 1) {\n                defaultContainer = containers[0];\n                return;\n            }\n\n            const containersPanel = document.getElementById('containers-panel');\n            containersPanel.classList.remove('display-none');\n            containersPanel.classList.add('display-inline-block');\n\n            const select = createElement('vscode-select');\n            select.setAttribute('id', 'containers-select');\n            // eslint-disable-next-line @typescript-eslint/prefer-for-of\n            for (let i = 0; i < containers.length; i += 1) {\n                const option = createElement('vscode-option', containers[i], containers[i]);\n                if (i === 0) {\n                    option.setAttribute('selected', '');\n                }\n                select.appendChild(option);\n            }\n            containersPanel.appendChild(select);\n        }\n        case 'content': {\n            const text = message.text;\n            if (!text) {\n                return;\n            }\n            const newContent = text.split('\\n');\n            updateContent(newContent, false);\n\n            // handle auto-scroll on/off\n            if (isToBottom) {\n                scrollToBottom();\n            }\n        }\n    }\n});\n\nfunction debounce(func, wait, immediate) {\n    let timeout;\n    return function() {\n        const context = this, args = arguments;\n        const later = function() {\n            timeout = null;\n            if (!immediate) {\n                func.apply(context, args);\n            }\n        };\n        const callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) {\n            func.apply(context, args);\n        }\n    };\n}\n\nfunction beautifyContentLineRange(contentLines, ix, end) {\n    if (ix && end) {\n        contentLines = contentLines.slice(ix, end);\n    }\n    return beautifyLines(contentLines);\n};\n\nfunction beautifyLines(contentLines) {\n    if (!contentLines) {\n        return '';\n    }\n    let content = contentLines.join('\\n');\n    if (content) {\n        content = content.match(/\\n$/) ? content : content + '\\n';\n        content = highlightWords(content);\n    }\n    return content;\n}\n\nfunction highlightWords(content) {\n    if (!schemaColors) {\n        return content;\n    }\n    for (const rule of schemaColors) {\n        const regexp = new RegExp(rule.regex, \"gi\");\n        content = content.replaceAll(regexp, repl);\n        content = content.replaceAll('#ruleColor', rule.color);\n    }\n    return content;\n}\n\nfunction repl(match, _word, offset, originalString) {\n    if (!originalString) {\n        return match;\n    }\n    const indexOpenSpan = originalString.substring(0, offset + match.length).lastIndexOf(\"<span\");\n    const indexCloseSpan = originalString.substring(0, offset + match.length).lastIndexOf(\"</span>\");\n    if (indexOpenSpan === -1) {\n        return `<span style=\"color:#ruleColor\">${match}</span>`;\n    } else if (indexOpenSpan !== -1 && indexCloseSpan === -1) {\n        return match;\n    } else if (indexOpenSpan < indexCloseSpan) {\n            return `<span style=\"color:#ruleColor\">${match}</span>`;\n    } else {\n        return match;\n    }\n}\n\nfunction filterNewLogs(logsText) {\n    return filter(logsText);\n}\n\nfunction filter(logs) {\n    let isNewLog = false;\n    let text = fullPageContent;\n    if (logs) {\n        isNewLog = true;\n        text = logs;\n    }\n    const filterInput = document.getElementById('filter-input').value;\n    const mode = document.getElementById('filter-select').value;\n    let content;\n    if (filterInput.length > 0 && mode !== 'all') {\n        const regex = new RegExp(filterInput);\n        switch (mode) {\n            case 'include':\n                content = text.filter((line) => regex.test(line));\n                break;\n            case 'exclude':\n                content = text.filter((line) => !regex.test(line));\n                break;\n            case 'before':\n                content = [];\n                if (!isNewLog) {\n                    for (const line of text) {\n                        if (regex.test(line)) {\n                            break;\n                        }\n                        content.push(line);\n                    }\n                }\n                break;\n            case 'after':\n                if (isNewLog) {\n                    content = text;\n                } else {\n                    const i = text.findIndex((line) => {\n                        return regex.test(line);\n                    });\n                    content = text.slice(i+1);\n                }\n                break;\n            default:\n                content = [];\n                break;\n        }\n    } else {\n        content = text;\n    }\n\n    return content;\n}\n\nfunction createElement(type, value, content) {\n    const element = document.createElement(type);\n    if (value) { element.value = value; }\n    if (content) { element.textContent = content; }\n    return element;\n}\n\nfunction init() {\n    const runBtn = document.getElementById('runBtn');\n    runBtn.addEventListener('click', (_event) => {\n        changeVisibilityAfterRun();\n        startLog();\n    });\n\n    const stopBtn = document.getElementById('stopBtn');\n    stopBtn.addEventListener('click', (_event) => {\n        changeVisibilityAfterStop();\n        stopLog();\n    });\n\n    const clearBtn = document.getElementById('clearBtn');\n    clearBtn.addEventListener('click', (_event) => {\n        changeVisibilityAfterClear();\n        clear();\n    });\n\n    const resetBtn = document.getElementById('resetBtn');\n    resetBtn.addEventListener('click', (_event) => {\n        reset();\n    });\n\n    const bottomBtn= document.getElementById('bottomBtn');\n    bottomBtn.addEventListener('click', (_event) => {\n        scrollToBottom();\n    });\n\n    const wrapChk = document.getElementById('wrap-chk');\n    wrapChk.addEventListener('vsc-change', function(event) {\n        const contentDiv = document.getElementById('content');\n        if (event.detail.checked) {\n            contentDiv.classList.remove('white-space-pre');\n            contentDiv.classList.add('white-space-wrap');\n        } else {\n            contentDiv.classList.remove('white-space-wrap');\n            contentDiv.classList.add('white-space-pre');\n        }\n    });\n\n    const filterSelect = document.getElementById('filter-select');\n    filterSelect.addEventListener('vsc-change', (_event) => {\n        runFilter();\n    });\n\n    const filterInput = document.getElementById('filter-input');\n    filterInput.addEventListener('keyup', (_event) => {\n        runFilter();\n    });\n\n    const logPanel = document.getElementById('logPanel');\n    const toBottom = debounce(function() {\n        const st = logPanel.scrollTop;\n        if (st > lastScrollTop){\n            // scroll down\n            isToBottom = (logPanel.scrollTop + window.innerHeight) >= logPanel.scrollHeight;\n        } else {\n            // scroll up\n            isToBottom = false;\n        }\n        lastScrollTop = st <= 0 ? 0 : st;\n    }, 250);\n    logPanel.addEventListener(\"scroll\", toBottom);\n}\n\nfunction runFilter() {\n    setTimeout(runFilterInternal, 0);\n}\n\nfunction runFilterInternal() {\n// We use this to abort renders in progress if a new render starts\n    renderNonce = Math.random();\n    const currentNonce = renderNonce;\n\n    const content = filter();\n\n    const contentDiv = document.getElementById('content');\n    contentDiv.textContent = !isFollow() ? 'No logs ...' : '';\n\n    // This is probably seems more complicated than necessary.\n    // However, rendering large blocks of text are _slow_ and kill the UI thread.\n    // So we split it up into manageable chunks to keep the UX lively.\n    // Of course the trouble is then we could interleave multiple different filters.\n    // So we use the random nonce to detect and pre-empt previous renders.\n    let ix = 0;\n    const step = 1000;\n    const fn = () => {\n        if (renderNonce !== currentNonce) {\n            return;\n        }\n        if (ix >= content.length) {\n            return;\n        }\n        const end = Math.min(content.length, ix + step);\n        setContentDiv(beautifyContentLineRange(content, ix, end));\n        ix += step;\n        setTimeout(fn, 0);\n    };\n    fn();\n}\n\nfunction changeVisibilityAfterRun() {\n    if (getToTerminal()) {\n        return;\n    }\n    document.getElementById('runBtn').classList.add('display-none');\n    if (isFollow()) {\n        switchClass('stopBtn', 'display-none', 'display-inline-block');\n    }\n    switchClass('clearBtn', 'display-none', 'display-inline-block');\n}\n\nfunction changeVisibilityAfterClear() {\n    switchClass('clearBtn', 'display-inline-block', 'display-none');\n\n    if (!isFollow()) {\n        switchClass('runBtn', 'display-none', 'display-inline-block');\n    }\n}\n\nfunction changeVisibilityAfterStop() {\n    switchClass('stopBtn', 'display-inline-block', 'display-none');\n\n    if (isFollow()) {\n        switchClass('runBtn', 'display-none', 'display-inline-block');\n    }\n}\n\nfunction switchClass(id, classToRemove, classToAdd) {\n    const element = document.getElementById(id);\n    if (element.classList.contains(classToRemove)) {\n        element.classList.remove(classToRemove);\n    }\n    if (!element.classList.contains(classToAdd)) {\n        element.classList.add(classToAdd);\n    }\n}\n\nfunction startLog() {\n    const options = {\n        container: getContainer(),\n        follow: isFollow(),\n        timestamp: document.getElementById('timestamp-chk').checked,\n        since: getSinceDuration(),\n        tail: getTail(),\n        terminal: getToTerminal()\n    };\n    vscode.postMessage({\n        command: 'start',\n        options: JSON.stringify(options)\n    });\n}\n\nfunction stopLog() {\n    vscode.postMessage({\n        command: 'stop'\n    });\n}\n\nfunction clear() {\n    fullPageContent.length = 0;\n    updateContent(undefined, true);\n}\n\nfunction reset() {\n    const containersSelect = document.getElementById('containers-select');\n    if (containersSelect) {\n        containersSelect.selectedIndex = 0;\n    }\n    document.getElementById('follow-chk').checked = false;\n    document.getElementById('timestamp-chk').checked = false;\n    document.getElementById('since-input').value = '0';\n    document.getElementById('since-select').selectedIndex = 0;\n    document.getElementById('tail-input').value = '-1';\n    document.getElementById('terminal-chk').checked = false;\n}\n\nfunction updateContent(newContent, clear) {\n    const contentDiv = document.getElementById('content');\n    if (clear) {\n        contentDiv.innerHTML = '';\n        return;\n    }\n\n    newContent.forEach((line) => {\n        if (line.length > 0) {\n            fullPageContent.push(line);\n        }\n    });\n    const beautifiedLines = beautifyLines(filterNewLogs(newContent));\n    setContentDiv(beautifiedLines);\n    switchClass('clearBtn', 'display-none', 'display-inline-block');\n}\n\nfunction setContentDiv(content) {\n    const contentDiv = document.getElementById('content');\n    if (!isFollow()) {\n        if (content === '') {\n            contentDiv.innerHTML = 'No logs ...';\n        } else {\n            contentDiv.innerHTML = content;\n        }\n    } else {\n        contentDiv.innerHTML += content;\n    }\n}\n\nfunction scrollToBottom () {\n    document.getElementById('bottom').scrollIntoView();\n}\n\nfunction getContainer() {\n    const containersSelect = document.getElementById('containers-select');\n    if (containersSelect) {\n        return containersSelect.value;\n    }\n    return defaultContainer;\n}\n\nfunction isFollow() {\n    return document.getElementById('follow-chk').checked;\n}\n\nfunction getSinceDuration() {\n    const sinceType = document.getElementById('since-select').value;\n    const sinceInput = document.getElementById('since-input').value;\n    if (isNaN(sinceInput) || sinceInput <= 0 || sinceType.trim() === '') {\n        return 0;\n    }\n    return `${sinceInput}${sinceType}`;\n}\n\nfunction getTail() {\n    const tailValue = document.getElementById('tail-input').value;\n    if (isNaN(tailValue) || tailValue <= 0) {\n        return -1;\n    }\n    return tailValue;\n}\n\nfunction getToTerminal() {\n    return document.getElementById('terminal-chk').checked;\n}\n\n(function() {\n    init();\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9sb2dzL2FwcC9tYWluLmpzP2ZiMzYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1QkFBdUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsTUFBTTtBQUN2RCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wscURBQXFELE1BQU07QUFDM0QsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDLGtCQUFrQiwrQkFBK0I7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVcsRUFBRSxVQUFVO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgdnNjb2RlID0gYWNxdWlyZVZzQ29kZUFwaSgpO1xuY29uc3QgZnVsbFBhZ2VDb250ZW50ID0gW107XG5sZXQgc2NoZW1hQ29sb3JzO1xubGV0IGRlZmF1bHRDb250YWluZXI7XG5sZXQgcmVuZGVyTm9uY2UgPSAwO1xubGV0IGlzVG9Cb3R0b20gPSB0cnVlO1xubGV0IGxhc3RTY3JvbGxUb3AgPSAwO1xuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIChldmVudCkgPT4ge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBldmVudC5kYXRhO1xuICAgIHN3aXRjaCAobWVzc2FnZS5jb21tYW5kKSB7XG4gICAgICAgIGNhc2UgJ2luaXQnOiB7XG4gICAgICAgICAgICBjb25zdCBjb250YWluZXJzID0gbWVzc2FnZS5jb250YWluZXJzO1xuICAgICAgICAgICAgc2NoZW1hQ29sb3JzID0gSlNPTi5wYXJzZShtZXNzYWdlLmNvbG9ycyk7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0Q29udGFpbmVyID0gY29udGFpbmVyc1swXTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lcnNQYW5lbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250YWluZXJzLXBhbmVsJyk7XG4gICAgICAgICAgICBjb250YWluZXJzUGFuZWwuY2xhc3NMaXN0LnJlbW92ZSgnZGlzcGxheS1ub25lJyk7XG4gICAgICAgICAgICBjb250YWluZXJzUGFuZWwuY2xhc3NMaXN0LmFkZCgnZGlzcGxheS1pbmxpbmUtYmxvY2snKTtcblxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ID0gY3JlYXRlRWxlbWVudCgndnNjb2RlLXNlbGVjdCcpO1xuICAgICAgICAgICAgc2VsZWN0LnNldEF0dHJpYnV0ZSgnaWQnLCAnY29udGFpbmVycy1zZWxlY3QnKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJlZmVyLWZvci1vZlxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250YWluZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9uID0gY3JlYXRlRWxlbWVudCgndnNjb2RlLW9wdGlvbicsIGNvbnRhaW5lcnNbaV0sIGNvbnRhaW5lcnNbaV0pO1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbi5zZXRBdHRyaWJ1dGUoJ3NlbGVjdGVkJywgJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxlY3QuYXBwZW5kQ2hpbGQob3B0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRhaW5lcnNQYW5lbC5hcHBlbmRDaGlsZChzZWxlY3QpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2NvbnRlbnQnOiB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gbWVzc2FnZS50ZXh0O1xuICAgICAgICAgICAgaWYgKCF0ZXh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV3Q29udGVudCA9IHRleHQuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgdXBkYXRlQ29udGVudChuZXdDb250ZW50LCBmYWxzZSk7XG5cbiAgICAgICAgICAgIC8vIGhhbmRsZSBhdXRvLXNjcm9sbCBvbi9vZmZcbiAgICAgICAgICAgIGlmIChpc1RvQm90dG9tKSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsVG9Cb3R0b20oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgICBsZXQgdGltZW91dDtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBjb25zdCBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoIWltbWVkaWF0ZSkge1xuICAgICAgICAgICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXQ7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgICAgICBpZiAoY2FsbE5vdykge1xuICAgICAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGJlYXV0aWZ5Q29udGVudExpbmVSYW5nZShjb250ZW50TGluZXMsIGl4LCBlbmQpIHtcbiAgICBpZiAoaXggJiYgZW5kKSB7XG4gICAgICAgIGNvbnRlbnRMaW5lcyA9IGNvbnRlbnRMaW5lcy5zbGljZShpeCwgZW5kKTtcbiAgICB9XG4gICAgcmV0dXJuIGJlYXV0aWZ5TGluZXMoY29udGVudExpbmVzKTtcbn07XG5cbmZ1bmN0aW9uIGJlYXV0aWZ5TGluZXMoY29udGVudExpbmVzKSB7XG4gICAgaWYgKCFjb250ZW50TGluZXMpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBsZXQgY29udGVudCA9IGNvbnRlbnRMaW5lcy5qb2luKCdcXG4nKTtcbiAgICBpZiAoY29udGVudCkge1xuICAgICAgICBjb250ZW50ID0gY29udGVudC5tYXRjaCgvXFxuJC8pID8gY29udGVudCA6IGNvbnRlbnQgKyAnXFxuJztcbiAgICAgICAgY29udGVudCA9IGhpZ2hsaWdodFdvcmRzKGNvbnRlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gY29udGVudDtcbn1cblxuZnVuY3Rpb24gaGlnaGxpZ2h0V29yZHMoY29udGVudCkge1xuICAgIGlmICghc2NoZW1hQ29sb3JzKSB7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHJ1bGUgb2Ygc2NoZW1hQ29sb3JzKSB7XG4gICAgICAgIGNvbnN0IHJlZ2V4cCA9IG5ldyBSZWdFeHAocnVsZS5yZWdleCwgXCJnaVwiKTtcbiAgICAgICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZUFsbChyZWdleHAsIHJlcGwpO1xuICAgICAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlQWxsKCcjcnVsZUNvbG9yJywgcnVsZS5jb2xvcik7XG4gICAgfVxuICAgIHJldHVybiBjb250ZW50O1xufVxuXG5mdW5jdGlvbiByZXBsKG1hdGNoLCBfd29yZCwgb2Zmc2V0LCBvcmlnaW5hbFN0cmluZykge1xuICAgIGlmICghb3JpZ2luYWxTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH1cbiAgICBjb25zdCBpbmRleE9wZW5TcGFuID0gb3JpZ2luYWxTdHJpbmcuc3Vic3RyaW5nKDAsIG9mZnNldCArIG1hdGNoLmxlbmd0aCkubGFzdEluZGV4T2YoXCI8c3BhblwiKTtcbiAgICBjb25zdCBpbmRleENsb3NlU3BhbiA9IG9yaWdpbmFsU3RyaW5nLnN1YnN0cmluZygwLCBvZmZzZXQgKyBtYXRjaC5sZW5ndGgpLmxhc3RJbmRleE9mKFwiPC9zcGFuPlwiKTtcbiAgICBpZiAoaW5kZXhPcGVuU3BhbiA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGA8c3BhbiBzdHlsZT1cImNvbG9yOiNydWxlQ29sb3JcIj4ke21hdGNofTwvc3Bhbj5gO1xuICAgIH0gZWxzZSBpZiAoaW5kZXhPcGVuU3BhbiAhPT0gLTEgJiYgaW5kZXhDbG9zZVNwYW4gPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9IGVsc2UgaWYgKGluZGV4T3BlblNwYW4gPCBpbmRleENsb3NlU3Bhbikge1xuICAgICAgICAgICAgcmV0dXJuIGA8c3BhbiBzdHlsZT1cImNvbG9yOiNydWxlQ29sb3JcIj4ke21hdGNofTwvc3Bhbj5gO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZpbHRlck5ld0xvZ3MobG9nc1RleHQpIHtcbiAgICByZXR1cm4gZmlsdGVyKGxvZ3NUZXh0KTtcbn1cblxuZnVuY3Rpb24gZmlsdGVyKGxvZ3MpIHtcbiAgICBsZXQgaXNOZXdMb2cgPSBmYWxzZTtcbiAgICBsZXQgdGV4dCA9IGZ1bGxQYWdlQ29udGVudDtcbiAgICBpZiAobG9ncykge1xuICAgICAgICBpc05ld0xvZyA9IHRydWU7XG4gICAgICAgIHRleHQgPSBsb2dzO1xuICAgIH1cbiAgICBjb25zdCBmaWx0ZXJJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmaWx0ZXItaW5wdXQnKS52YWx1ZTtcbiAgICBjb25zdCBtb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZpbHRlci1zZWxlY3QnKS52YWx1ZTtcbiAgICBsZXQgY29udGVudDtcbiAgICBpZiAoZmlsdGVySW5wdXQubGVuZ3RoID4gMCAmJiBtb2RlICE9PSAnYWxsJykge1xuICAgICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoZmlsdGVySW5wdXQpO1xuICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2luY2x1ZGUnOlxuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSB0ZXh0LmZpbHRlcigobGluZSkgPT4gcmVnZXgudGVzdChsaW5lKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdleGNsdWRlJzpcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gdGV4dC5maWx0ZXIoKGxpbmUpID0+ICFyZWdleC50ZXN0KGxpbmUpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2JlZm9yZSc6XG4gICAgICAgICAgICAgICAgY29udGVudCA9IFtdO1xuICAgICAgICAgICAgICAgIGlmICghaXNOZXdMb2cpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIHRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWdleC50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50LnB1c2gobGluZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhZnRlcic6XG4gICAgICAgICAgICAgICAgaWYgKGlzTmV3TG9nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSB0ZXh0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGkgPSB0ZXh0LmZpbmRJbmRleCgobGluZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlZ2V4LnRlc3QobGluZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gdGV4dC5zbGljZShpKzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29udGVudCA9IFtdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29udGVudCA9IHRleHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodHlwZSwgdmFsdWUsIGNvbnRlbnQpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTtcbiAgICBpZiAodmFsdWUpIHsgZWxlbWVudC52YWx1ZSA9IHZhbHVlOyB9XG4gICAgaWYgKGNvbnRlbnQpIHsgZWxlbWVudC50ZXh0Q29udGVudCA9IGNvbnRlbnQ7IH1cbiAgICByZXR1cm4gZWxlbWVudDtcbn1cblxuZnVuY3Rpb24gaW5pdCgpIHtcbiAgICBjb25zdCBydW5CdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncnVuQnRuJyk7XG4gICAgcnVuQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKF9ldmVudCkgPT4ge1xuICAgICAgICBjaGFuZ2VWaXNpYmlsaXR5QWZ0ZXJSdW4oKTtcbiAgICAgICAgc3RhcnRMb2coKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHN0b3BCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3RvcEJ0bicpO1xuICAgIHN0b3BCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoX2V2ZW50KSA9PiB7XG4gICAgICAgIGNoYW5nZVZpc2liaWxpdHlBZnRlclN0b3AoKTtcbiAgICAgICAgc3RvcExvZygpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgY2xlYXJCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2xlYXJCdG4nKTtcbiAgICBjbGVhckJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChfZXZlbnQpID0+IHtcbiAgICAgICAgY2hhbmdlVmlzaWJpbGl0eUFmdGVyQ2xlYXIoKTtcbiAgICAgICAgY2xlYXIoKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHJlc2V0QnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jlc2V0QnRuJyk7XG4gICAgcmVzZXRCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoX2V2ZW50KSA9PiB7XG4gICAgICAgIHJlc2V0KCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBib3R0b21CdG49IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdib3R0b21CdG4nKTtcbiAgICBib3R0b21CdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoX2V2ZW50KSA9PiB7XG4gICAgICAgIHNjcm9sbFRvQm90dG9tKCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCB3cmFwQ2hrID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dyYXAtY2hrJyk7XG4gICAgd3JhcENoay5hZGRFdmVudExpc3RlbmVyKCd2c2MtY2hhbmdlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgY29uc3QgY29udGVudERpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250ZW50Jyk7XG4gICAgICAgIGlmIChldmVudC5kZXRhaWwuY2hlY2tlZCkge1xuICAgICAgICAgICAgY29udGVudERpdi5jbGFzc0xpc3QucmVtb3ZlKCd3aGl0ZS1zcGFjZS1wcmUnKTtcbiAgICAgICAgICAgIGNvbnRlbnREaXYuY2xhc3NMaXN0LmFkZCgnd2hpdGUtc3BhY2Utd3JhcCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGVudERpdi5jbGFzc0xpc3QucmVtb3ZlKCd3aGl0ZS1zcGFjZS13cmFwJyk7XG4gICAgICAgICAgICBjb250ZW50RGl2LmNsYXNzTGlzdC5hZGQoJ3doaXRlLXNwYWNlLXByZScpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBmaWx0ZXJTZWxlY3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZmlsdGVyLXNlbGVjdCcpO1xuICAgIGZpbHRlclNlbGVjdC5hZGRFdmVudExpc3RlbmVyKCd2c2MtY2hhbmdlJywgKF9ldmVudCkgPT4ge1xuICAgICAgICBydW5GaWx0ZXIoKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGZpbHRlcklucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZpbHRlci1pbnB1dCcpO1xuICAgIGZpbHRlcklucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgKF9ldmVudCkgPT4ge1xuICAgICAgICBydW5GaWx0ZXIoKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGxvZ1BhbmVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xvZ1BhbmVsJyk7XG4gICAgY29uc3QgdG9Cb3R0b20gPSBkZWJvdW5jZShmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3Qgc3QgPSBsb2dQYW5lbC5zY3JvbGxUb3A7XG4gICAgICAgIGlmIChzdCA+IGxhc3RTY3JvbGxUb3Ape1xuICAgICAgICAgICAgLy8gc2Nyb2xsIGRvd25cbiAgICAgICAgICAgIGlzVG9Cb3R0b20gPSAobG9nUGFuZWwuc2Nyb2xsVG9wICsgd2luZG93LmlubmVySGVpZ2h0KSA+PSBsb2dQYW5lbC5zY3JvbGxIZWlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzY3JvbGwgdXBcbiAgICAgICAgICAgIGlzVG9Cb3R0b20gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0U2Nyb2xsVG9wID0gc3QgPD0gMCA/IDAgOiBzdDtcbiAgICB9LCAyNTApO1xuICAgIGxvZ1BhbmVsLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdG9Cb3R0b20pO1xufVxuXG5mdW5jdGlvbiBydW5GaWx0ZXIoKSB7XG4gICAgc2V0VGltZW91dChydW5GaWx0ZXJJbnRlcm5hbCwgMCk7XG59XG5cbmZ1bmN0aW9uIHJ1bkZpbHRlckludGVybmFsKCkge1xuLy8gV2UgdXNlIHRoaXMgdG8gYWJvcnQgcmVuZGVycyBpbiBwcm9ncmVzcyBpZiBhIG5ldyByZW5kZXIgc3RhcnRzXG4gICAgcmVuZGVyTm9uY2UgPSBNYXRoLnJhbmRvbSgpO1xuICAgIGNvbnN0IGN1cnJlbnROb25jZSA9IHJlbmRlck5vbmNlO1xuXG4gICAgY29uc3QgY29udGVudCA9IGZpbHRlcigpO1xuXG4gICAgY29uc3QgY29udGVudERpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250ZW50Jyk7XG4gICAgY29udGVudERpdi50ZXh0Q29udGVudCA9ICFpc0ZvbGxvdygpID8gJ05vIGxvZ3MgLi4uJyA6ICcnO1xuXG4gICAgLy8gVGhpcyBpcyBwcm9iYWJseSBzZWVtcyBtb3JlIGNvbXBsaWNhdGVkIHRoYW4gbmVjZXNzYXJ5LlxuICAgIC8vIEhvd2V2ZXIsIHJlbmRlcmluZyBsYXJnZSBibG9ja3Mgb2YgdGV4dCBhcmUgX3Nsb3dfIGFuZCBraWxsIHRoZSBVSSB0aHJlYWQuXG4gICAgLy8gU28gd2Ugc3BsaXQgaXQgdXAgaW50byBtYW5hZ2VhYmxlIGNodW5rcyB0byBrZWVwIHRoZSBVWCBsaXZlbHkuXG4gICAgLy8gT2YgY291cnNlIHRoZSB0cm91YmxlIGlzIHRoZW4gd2UgY291bGQgaW50ZXJsZWF2ZSBtdWx0aXBsZSBkaWZmZXJlbnQgZmlsdGVycy5cbiAgICAvLyBTbyB3ZSB1c2UgdGhlIHJhbmRvbSBub25jZSB0byBkZXRlY3QgYW5kIHByZS1lbXB0IHByZXZpb3VzIHJlbmRlcnMuXG4gICAgbGV0IGl4ID0gMDtcbiAgICBjb25zdCBzdGVwID0gMTAwMDtcbiAgICBjb25zdCBmbiA9ICgpID0+IHtcbiAgICAgICAgaWYgKHJlbmRlck5vbmNlICE9PSBjdXJyZW50Tm9uY2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXggPj0gY29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbmQgPSBNYXRoLm1pbihjb250ZW50Lmxlbmd0aCwgaXggKyBzdGVwKTtcbiAgICAgICAgc2V0Q29udGVudERpdihiZWF1dGlmeUNvbnRlbnRMaW5lUmFuZ2UoY29udGVudCwgaXgsIGVuZCkpO1xuICAgICAgICBpeCArPSBzdGVwO1xuICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICB9O1xuICAgIGZuKCk7XG59XG5cbmZ1bmN0aW9uIGNoYW5nZVZpc2liaWxpdHlBZnRlclJ1bigpIHtcbiAgICBpZiAoZ2V0VG9UZXJtaW5hbCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3J1bkJ0bicpLmNsYXNzTGlzdC5hZGQoJ2Rpc3BsYXktbm9uZScpO1xuICAgIGlmIChpc0ZvbGxvdygpKSB7XG4gICAgICAgIHN3aXRjaENsYXNzKCdzdG9wQnRuJywgJ2Rpc3BsYXktbm9uZScsICdkaXNwbGF5LWlubGluZS1ibG9jaycpO1xuICAgIH1cbiAgICBzd2l0Y2hDbGFzcygnY2xlYXJCdG4nLCAnZGlzcGxheS1ub25lJywgJ2Rpc3BsYXktaW5saW5lLWJsb2NrJyk7XG59XG5cbmZ1bmN0aW9uIGNoYW5nZVZpc2liaWxpdHlBZnRlckNsZWFyKCkge1xuICAgIHN3aXRjaENsYXNzKCdjbGVhckJ0bicsICdkaXNwbGF5LWlubGluZS1ibG9jaycsICdkaXNwbGF5LW5vbmUnKTtcblxuICAgIGlmICghaXNGb2xsb3coKSkge1xuICAgICAgICBzd2l0Y2hDbGFzcygncnVuQnRuJywgJ2Rpc3BsYXktbm9uZScsICdkaXNwbGF5LWlubGluZS1ibG9jaycpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY2hhbmdlVmlzaWJpbGl0eUFmdGVyU3RvcCgpIHtcbiAgICBzd2l0Y2hDbGFzcygnc3RvcEJ0bicsICdkaXNwbGF5LWlubGluZS1ibG9jaycsICdkaXNwbGF5LW5vbmUnKTtcblxuICAgIGlmIChpc0ZvbGxvdygpKSB7XG4gICAgICAgIHN3aXRjaENsYXNzKCdydW5CdG4nLCAnZGlzcGxheS1ub25lJywgJ2Rpc3BsYXktaW5saW5lLWJsb2NrJyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzd2l0Y2hDbGFzcyhpZCwgY2xhc3NUb1JlbW92ZSwgY2xhc3NUb0FkZCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzVG9SZW1vdmUpKSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc1RvUmVtb3ZlKTtcbiAgICB9XG4gICAgaWYgKCFlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc1RvQWRkKSkge1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NUb0FkZCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzdGFydExvZygpIHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBjb250YWluZXI6IGdldENvbnRhaW5lcigpLFxuICAgICAgICBmb2xsb3c6IGlzRm9sbG93KCksXG4gICAgICAgIHRpbWVzdGFtcDogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RpbWVzdGFtcC1jaGsnKS5jaGVja2VkLFxuICAgICAgICBzaW5jZTogZ2V0U2luY2VEdXJhdGlvbigpLFxuICAgICAgICB0YWlsOiBnZXRUYWlsKCksXG4gICAgICAgIHRlcm1pbmFsOiBnZXRUb1Rlcm1pbmFsKClcbiAgICB9O1xuICAgIHZzY29kZS5wb3N0TWVzc2FnZSh7XG4gICAgICAgIGNvbW1hbmQ6ICdzdGFydCcsXG4gICAgICAgIG9wdGlvbnM6IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpXG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHN0b3BMb2coKSB7XG4gICAgdnNjb2RlLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgY29tbWFuZDogJ3N0b3AnXG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGZ1bGxQYWdlQ29udGVudC5sZW5ndGggPSAwO1xuICAgIHVwZGF0ZUNvbnRlbnQodW5kZWZpbmVkLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgY29uc3QgY29udGFpbmVyc1NlbGVjdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250YWluZXJzLXNlbGVjdCcpO1xuICAgIGlmIChjb250YWluZXJzU2VsZWN0KSB7XG4gICAgICAgIGNvbnRhaW5lcnNTZWxlY3Quc2VsZWN0ZWRJbmRleCA9IDA7XG4gICAgfVxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmb2xsb3ctY2hrJykuY2hlY2tlZCA9IGZhbHNlO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0aW1lc3RhbXAtY2hrJykuY2hlY2tlZCA9IGZhbHNlO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzaW5jZS1pbnB1dCcpLnZhbHVlID0gJzAnO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzaW5jZS1zZWxlY3QnKS5zZWxlY3RlZEluZGV4ID0gMDtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndGFpbC1pbnB1dCcpLnZhbHVlID0gJy0xJztcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndGVybWluYWwtY2hrJykuY2hlY2tlZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDb250ZW50KG5ld0NvbnRlbnQsIGNsZWFyKSB7XG4gICAgY29uc3QgY29udGVudERpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250ZW50Jyk7XG4gICAgaWYgKGNsZWFyKSB7XG4gICAgICAgIGNvbnRlbnREaXYuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBuZXdDb250ZW50LmZvckVhY2goKGxpbmUpID0+IHtcbiAgICAgICAgaWYgKGxpbmUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZnVsbFBhZ2VDb250ZW50LnB1c2gobGluZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBiZWF1dGlmaWVkTGluZXMgPSBiZWF1dGlmeUxpbmVzKGZpbHRlck5ld0xvZ3MobmV3Q29udGVudCkpO1xuICAgIHNldENvbnRlbnREaXYoYmVhdXRpZmllZExpbmVzKTtcbiAgICBzd2l0Y2hDbGFzcygnY2xlYXJCdG4nLCAnZGlzcGxheS1ub25lJywgJ2Rpc3BsYXktaW5saW5lLWJsb2NrJyk7XG59XG5cbmZ1bmN0aW9uIHNldENvbnRlbnREaXYoY29udGVudCkge1xuICAgIGNvbnN0IGNvbnRlbnREaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29udGVudCcpO1xuICAgIGlmICghaXNGb2xsb3coKSkge1xuICAgICAgICBpZiAoY29udGVudCA9PT0gJycpIHtcbiAgICAgICAgICAgIGNvbnRlbnREaXYuaW5uZXJIVE1MID0gJ05vIGxvZ3MgLi4uJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRlbnREaXYuaW5uZXJIVE1MID0gY29udGVudDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRlbnREaXYuaW5uZXJIVE1MICs9IGNvbnRlbnQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzY3JvbGxUb0JvdHRvbSAoKSB7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2JvdHRvbScpLnNjcm9sbEludG9WaWV3KCk7XG59XG5cbmZ1bmN0aW9uIGdldENvbnRhaW5lcigpIHtcbiAgICBjb25zdCBjb250YWluZXJzU2VsZWN0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRhaW5lcnMtc2VsZWN0Jyk7XG4gICAgaWYgKGNvbnRhaW5lcnNTZWxlY3QpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcnNTZWxlY3QudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0Q29udGFpbmVyO1xufVxuXG5mdW5jdGlvbiBpc0ZvbGxvdygpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZvbGxvdy1jaGsnKS5jaGVja2VkO1xufVxuXG5mdW5jdGlvbiBnZXRTaW5jZUR1cmF0aW9uKCkge1xuICAgIGNvbnN0IHNpbmNlVHlwZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzaW5jZS1zZWxlY3QnKS52YWx1ZTtcbiAgICBjb25zdCBzaW5jZUlucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NpbmNlLWlucHV0JykudmFsdWU7XG4gICAgaWYgKGlzTmFOKHNpbmNlSW5wdXQpIHx8IHNpbmNlSW5wdXQgPD0gMCB8fCBzaW5jZVR5cGUudHJpbSgpID09PSAnJykge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIGAke3NpbmNlSW5wdXR9JHtzaW5jZVR5cGV9YDtcbn1cblxuZnVuY3Rpb24gZ2V0VGFpbCgpIHtcbiAgICBjb25zdCB0YWlsVmFsdWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndGFpbC1pbnB1dCcpLnZhbHVlO1xuICAgIGlmIChpc05hTih0YWlsVmFsdWUpIHx8IHRhaWxWYWx1ZSA8PSAwKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIHRhaWxWYWx1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0VG9UZXJtaW5hbCgpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Rlcm1pbmFsLWNoaycpLmNoZWNrZWQ7XG59XG5cbihmdW5jdGlvbigpIHtcbiAgICBpbml0KCk7XG59KSgpOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n")}]);