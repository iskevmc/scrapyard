"use strict";
//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", { value: true });
const uuid = require("uuid");
const privacy_1 = require("../privacy");
const telemetryStrings_1 = require("./telemetryStrings");
const Result_1 = require("../types/Result");
const FaultType_1 = require("../types/FaultType");
function defaultErrorToString(e) {
    if (!e) {
        return null;
    }
    let s = e.message || 'Unknown error';
    let stack = e.stack || null;
    if (stack) {
        s += '\n' + stack;
    }
    return s;
}
class TelemetryDef {
    constructor() {
        this.telemetryEvents = {};
        this.filters = [];
    }
    init(reporter, featureName, readLogsParam, errorToStringParam) {
        this.reporter = reporter;
        telemetryStrings_1.TelemetryPropertyNames.FEATURE_NAME = featureName || '';
        readLogs = readLogsParam;
        errorToString = errorToStringParam ? errorToStringParam : defaultErrorToString;
        this.contextProperties = {};
        Telemetry.addContextProperty(telemetryStrings_1.TelemetryPropertyNames.SESSION_ID, uuid());
    }
    addFilter(filter) {
        this.filters.push(filter);
    }
    removeFilter(filter) {
        const idx = this.filters.indexOf(filter);
        if (idx >= 0) {
            this.filters.splice(idx, 1);
        }
    }
    addContextProperty(property, value, isSensitive = false, canSendSensitiveInformation = false) {
        // no need to set `undefined` values
        if (value === undefined) {
            return;
        }
        const valueString = String(value);
        if (isSensitive && !canSendSensitiveInformation) {
            this.contextProperties[property] = privacy_1.Privacy.getShortHash(valueString);
        }
        else {
            this.contextProperties[property] = valueString;
        }
    }
    removeContextProperty(property) {
        delete this.contextProperties[property];
    }
    addContextPropertiesToObject(properties) {
        return Object.assign({}, this.contextProperties, properties);
    }
    sendTelemetryEvent(eventName, properties, measures) {
        const augmentedProperties = this.addContextPropertiesToObject(properties);
        for (const filter of this.filters) {
            if (!filter.shouldSend(eventName, augmentedProperties, measures)) {
                return;
            }
        }
        this.reporter.sendTelemetryEvent(eventName, augmentedProperties, measures);
    }
    sendFault(eventName, type, details, exception, correlatedEvent) {
        new Fault(eventName, type, details, exception, correlatedEvent).send();
    }
    startTimedEvent(eventName, correlate = false) {
        const timedEvent = new TimedEvent(eventName, correlate);
        // save the event to telemetry events queue
        this.telemetryEvents[timedEvent.id] = timedEvent;
        return timedEvent;
    }
    setCorrelationEvent(correlationEvent) {
        this.correlationEvent = correlationEvent;
    }
    removeCorrelationEvent(correlationEvent) {
        if (this.correlationEvent === correlationEvent) {
            this.correlationEvent = undefined;
        }
    }
    correlate(telemetryEvent) {
        if (this.correlationEvent) {
            telemetryEvent.correlateWith(this.correlationEvent);
        }
    }
    async endAllPendingEvents() {
        for (let eventId of Object.keys(this.telemetryEvents)) {
            const event = this.telemetryEvents[eventId];
            await event.endIfNotSent();
            delete this.telemetryEvents[eventId];
        }
    }
}
exports.TelemetryDef = TelemetryDef;
// tslint:disable-next-line: variable-name
const Telemetry = new TelemetryDef();
exports.Telemetry = Telemetry;
let readLogs;
let errorToString;
class TelemetryEvent {
    constructor(eventName, correlate = false) {
        this.isSent = false;
        this.id = uuid();
        this.eventName = eventName;
        this.properties = {};
        this.measures = {};
        this.correlationId = uuid();
        if (correlate) {
            Telemetry.correlate(this);
        }
    }
    static create(property, data) {
        const correlate = data ? !!data.correlate : false;
        const telemetryEvent = new TelemetryEvent(property, correlate);
        if (data.properties) {
            Object.keys(data.properties).forEach((key) => telemetryEvent.addProperty(telemetryStrings_1.TelemetryPropertyNames.FEATURE_NAME + key, data.properties[key]));
        }
        if (data.measures) {
            Object.keys(data.measures).forEach((key) => telemetryEvent.addMeasure(telemetryStrings_1.TelemetryPropertyNames.FEATURE_NAME + key, data.measures[key]));
        }
        return telemetryEvent;
    }
    addProperty(property, value, isSensitive = false, canSendSensitiveInformation = false) {
        // no need to set `undefined` values
        if (value === undefined) {
            return this;
        }
        const valueString = String(value);
        if (isSensitive && !canSendSensitiveInformation) {
            this.properties[property] = privacy_1.Privacy.getShortHash(valueString);
        }
        else {
            this.properties[property] = valueString;
        }
        return this;
    }
    addPropertyIfNotExists(property, value, isSensitive = false) {
        if (!this.propertyExists(property)) {
            this.addProperty(property, value, isSensitive);
        }
        return this;
    }
    propertyExists(property) {
        return property in this.properties;
    }
    addMeasure(measure, value) {
        this.measures[measure] = value;
    }
    addMeasureIfNotExists(measure, value) {
        if (this.measures[measure] === undefined) {
            this.addMeasure(measure, value);
        }
    }
    getCorrelationId() {
        return this.correlationId;
    }
    correlateWith(otherEvent) {
        this.correlationId = otherEvent.getCorrelationId();
        return this;
    }
    correlateWithId(correlationId) {
        this.correlationId = correlationId;
        return this;
    }
    async send() {
        this.addProperty(telemetryStrings_1.TelemetryPropertyNames.CORRELATION_ID, this.correlationId);
        Telemetry.sendTelemetryEvent(this.eventName, this.properties, this.measures);
        this.isSent = true;
    }
}
exports.TelemetryEvent = TelemetryEvent;
function removeEmailAddresses(str) {
    return str.replace(/[\S]+@[\S]+/gi, '[EMAIL]');
}
const removePath = (filePath, replacementString) => {
    return filePath.replace(/([A-Za-z]:)?(\S*[\\\/])+\S*/gi, (match, drive, directory, offset, whole) => {
        if (/^\d{1,4}\/\d{1,2}\/\d{1,4}$/.test(match)) {
            // This is a date. No need to scrub.
            return match;
        }
        else {
            const driveAndDirectoryLength = (drive ? drive.length : 0) + directory.length;
            const fileName = match.substr(driveAndDirectoryLength);
            return replacementString + fileName;
        }
    });
};
function cleanSensitiveInformation(str) {
    return str ? removeEmailAddresses(removePath(str, '[PATH]/')) : str;
}
exports.cleanSensitiveInformation = cleanSensitiveInformation;
class Fault extends TelemetryEvent {
    constructor(eventName, type, details, exception, correlatedEvent) {
        super(eventName);
        this.addProperty(telemetryStrings_1.TelemetryPropertyNames.FAULT_TYPE, FaultType_1.FaultType[type]);
        if (details) {
            this.addProperty(telemetryStrings_1.TelemetryPropertyNames.EVENT_MESSAGE, cleanSensitiveInformation(details));
        }
        let exceptionStack = '';
        // no rpc in the framework
        if (exception && exception.stack && typeof exception.stack === 'string') {
            exceptionStack += cleanSensitiveInformation(errorToString(exception));
        }
        if (!exceptionStack) {
            exceptionStack = 'No Stack';
        }
        this.addProperty(telemetryStrings_1.TelemetryPropertyNames.EVENT_EXCEPTION_STACK, exceptionStack);
        if (correlatedEvent) {
            this.correlateWith(correlatedEvent);
        }
    }
    async attachLogs() {
        if (readLogs) {
            const logLines = await readLogs();
            this.addProperty(telemetryStrings_1.TelemetryPropertyNames.LOG_LINES, cleanSensitiveInformation(logLines));
        }
    }
    async send() {
        await this.attachLogs();
        return super.send();
    }
}
exports.Fault = Fault;
class TimedEvent extends TelemetryEvent {
    constructor(eventName, correlate = false) {
        super(eventName, correlate);
        this.startTime = new Date().getTime();
        this.lastMarkTime = this.startTime;
        TimedEvent.scopeStack.push(this);
    }
    markTime(markName, fromStart = false) {
        let currentTime = new Date().getTime();
        let duration = fromStart ? currentTime - this.startTime : currentTime - this.lastMarkTime;
        this.lastMarkTime = currentTime;
        this.addMeasure(markName, duration);
        return duration;
    }
    end(result, message, sendNow = true) {
        this.addProperty(telemetryStrings_1.TelemetryPropertyNames.EVENT_RESULT, Result_1.Result[result]);
        if (message) {
            this.addProperty(telemetryStrings_1.TelemetryPropertyNames.EVENT_MESSAGE, cleanSensitiveInformation(message));
        }
        const duration = this.markTime(telemetryStrings_1.TelemetryPropertyNames.EVENT_DURATION, true);
        Telemetry.removeCorrelationEvent(this);
        if (sendNow) {
            this.send();
        }
        for (let i = TimedEvent.scopeStack.length - 1; i >= 0; i--) {
            if (TimedEvent.scopeStack[i] === this) {
                TimedEvent.scopeStack.splice(i, 1);
            }
        }
        return duration;
    }
    async endIfNotSent() {
        if (this.isSent) {
            return;
        }
        await this.end(Result_1.Result.Cancel, 'Completing pending telemetry events.');
    }
}
TimedEvent.scopeStack = [];
exports.propagateOffsetMarkTime = (markName, markEvent) => {
    for (let i = 0; i < TimedEvent.scopeStack.length; i++) {
        const targetEvent = TimedEvent.scopeStack[i];
        if (targetEvent !== markEvent) {
            targetEvent.markTime(markName);
        }
    }
};
//# sourceMappingURL=telemetry.js.map